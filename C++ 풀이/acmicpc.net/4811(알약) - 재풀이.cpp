#include <iostream>

using namespace std;

#define SIZE 30 + 1

int main() {
	long long dp[SIZE][SIZE] = { {0} };

	for (int h = 1; h < SIZE; h++) {
		dp[0][h] = 1;
	}

	for (int w = 1; w < SIZE; w++) {
		for (int h = 0; h < SIZE; h++) {
			if (h == 0) {
				dp[w][h] = dp[w - 1][h + 1];
			}
			else {
				dp[w][h] = dp[w - 1][h + 1] + dp[w][h - 1];
			}
		}
	}

	/*for (int w = 0; w < 11; w++) {
		for (int h = 0; h < 11; h++) {
			cout << dp[w][h] << ' ';
		}
		cout << '\n';
	}*/


	int n;

	for (;;) {
		cin >> n;

		if (n == 0) {
			break;
		}

		cout << dp[n][0] << '\n';
	}

	return 0;
}

/*
dp[w][h]는 현재 한쪽이 w개, 반쪽이 h개라는 상태를 나타낸다.
위 상태에서 행할 수 있는 행위를 생각하여 점화식을 만들어야한다.

점화식 유도.
1. dp[w][h] 상태에서 행위는 크게 1. w(한쪽)을 뽑는 것과 2. h(반쪽)을 뽑는 경우로 나눌 수 있다.
2. 만약 한쪽을 뽑았다면 한쪽을 반으로 자를 때 한쪽은 없어지고 반쪽이 두개 느는데,
이 때 반쪽짜리를 하나 먹음으로써 반쪽은 1개만 늘어나게 된다.
따라서 한쪽을 뽑은 경우 dp[w][h] = dp[w-1][h+1]로 정의할 수 있겠다.
3. 만약 반쪽을 뽑았다면 반쪽짜리는 바로 먹을 수 있음으로 반쪽만 없어지게 된다.
이에 따라 반쪽을 뽑은 경우 dp[w][h] = dp[w][h-1]로 정의할 수 있겠다.
4. dp[w][h]에 대해서 2,3케이스(한쪽을 뽑는경우와 반쪽을 뽑는 경우)를 모두 봐야하니,
점화식은 dp[w][h] = dp[w-1][h+1](한쪽을 뽑는 경우) + dp[w][h-1](반쪽을 뽑는 경우)로 정의된다.

유의 할 점.
1. dp를 사용할 때는 초기값 설정이 필요하다.
이 문제에서는 알약이 h로만 구성된 경우의 dp[0][h]에 1을 할당(dp[0][h] = 1)하여 초기값을 설정하고 dp를 계산한다.
h로만 알약이 구성되어있을 때 뽑을 수 있는 경우의 수는 1가지 밖에(h,hhh,hhhhh...) 없기 때문이다.
또 위 값을 1로 설정해두었을 때 buttom-up 방식을 사용할 수 있기에 dp[0][h]을 통해 초기값을 설정해주었다.
2. dp[w][0]인 경우 반쪽짜리가 없음으로 무조건 한쪽짜리를 뽑을 수 밖에없다.
이에 따라 h==0인 경우,dp[w][h(0)] = dp[w-1][h+1]가 된다.

결과 출력.
dp[n][0]은 종수가 알약을 받은 완전 초기 상태를 의미한다.
초기에는 w가 n개인 상태로 시작되고 h는 0개이기 때문에 결국 dp[n][0]은 초기 상태에서 알약을 먹을 수 있는 경우의 수를 의미하게 된다.
*/